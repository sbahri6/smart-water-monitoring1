<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1220">
  <title>Smart Water — Live (Malaysia TZ, Controls)</title>

  <style>
    :root{
      --bg:#0b1220; --card:#0f1724; --text:#e6eef8; --muted:#9fb2d1;
      --accent:#2dd4bf; --accent-dark:#02867a;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--text);-webkit-text-size-adjust:100%}
    .wrap{max-width:1100px;margin:0 auto;padding:12px;box-sizing:border-box}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{font-size:16px;margin:0}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:10px;box-sizing:border-box;flex:1 1 280px;min-width:260px}
    canvas{width:100% !important;height:160px !important;display:block}
    .gaugeWrap{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .gaugeCard{flex:1 1 180px;min-width:160px;display:flex;flex-direction:column;align-items:center;gap:6px}
    .label{font-size:12px;color:var(--muted)}
    .big{font-size:20px;font-weight:600}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    button{appearance:none;border:0;padding:8px 12px;border-radius:8px;background:#142032;color:var(--text);cursor:pointer;font-size:13px;min-width:110px;white-space:nowrap}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04)}
    .btn-on{background:var(--accent);color:#021617;border:1px solid rgba(0,0,0,0.12);font-weight:700;box-shadow:0 6px 18px rgba(0,0,0,0.35)}
    footer{margin-top:16px;color:var(--muted);font-size:12px;text-align:center}
    .small{font-size:12px;color:var(--muted)}
    hr{border:none;border-top:1px solid rgba(255,255,255,0.03)}
    @media(min-width:900px){
      canvas{height:200px !important}
    }
  </style>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Smart Water • Live</h1>
      <div class="small" id="status">connecting...</div>
    </header>

    <div class="row">
      <div class="card" style="flex:2 1 520px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="label">History (last ~500 points) — Malaysia time</div>
            <div class="small">Auto-refresh every 5s</div>
          </div>
          <div>
            <button id="refreshBtn" class="secondary">Refresh</button>
          </div>
        </div>

        <div style="margin-top:10px">
          <canvas id="soil1Chart"></canvas>
        </div>
        <div style="margin-top:8px">
          <canvas id="soil2Chart"></canvas>
        </div>
        <div style="margin-top:8px">
          <canvas id="drainageChart"></canvas>
        </div>
      </div>

      <div style="flex:1 1 320px;min-width:280px">
        <div class="card">
          <div class="label">Live gauges</div>
          <div class="gaugeWrap" style="margin-top:8px">
            <div class="gaugeCard">
              <canvas id="gsoil1" width="260" height="160"></canvas>
              <div class="label">Soil 1</div>
              <div class="big" id="gsoil1Val">--%</div>
            </div>
            <div class="gaugeCard">
              <canvas id="gsoil2" width="260" height="160"></canvas>
              <div class="label">Soil 2</div>
              <div class="big" id="gsoil2Val">--%</div>
            </div>
            <div class="gaugeCard">
              <canvas id="gdrain" width="260" height="160"></canvas>
              <div class="label">Drainage</div>
              <div class="big" id="gdrainVal">--%</div>
            </div>
          </div>

          <hr style="opacity:.05;margin:12px 0" />

          <div class="label">Controls (writes to /devices/&lt;DEVICE_ID&gt;/controls)</div>
          <div class="controls" style="margin-top:8px">
            <div style="display:flex;flex-direction:column;gap:6px">
              <div class="small">Farm pump</div>
              <div style="display:flex;gap:6px">
                <button id="farmManualToggle" class="secondary">Manual: Off</button>
                <button id="farmDesiredToggle" class="secondary">Desired: OFF</button>
              </div>
            </div>

            <div style="display:flex;flex-direction:column;gap:6px">
              <div class="small">Drainage pump</div>
              <div style="display:flex;gap:6px">
                <button id="drainManualToggle" class="secondary">Manual: Off</button>
                <button id="drainDesiredToggle" class="secondary">Desired: OFF</button>
              </div>
            </div>
          </div>

          <div style="margin-top:12px" class="small">
            Note: the ESP32 reads /controls and applies them. The web UI writes only to /controls — ESP reports real outputs in /status.
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="label">Session</div>
          <div class="small" id="sessionInfo">---</div>
        </div>
      </div>
    </div>

    <footer>Built for speed • Replace API keys in the top of the page • Hosted on GitHub Pages</footer>
  </div>

  <!-- Firebase + main logic -->
  <script type="module">
    // ====== CONFIG - Replace these with your project's values ======
    const FIREBASE_API_KEY = "AIzaSyCdl2doXjpZsmQZtWzdHWuG-4cTwSsEGOE"; // ← REPLACE
    const DATABASE_URL = "https://drams-5854f-default-rtdb.firebaseio.com"; // ← REPLACE (no trailing slash)
    const DEVICE_ID = "esp32_device_001"; // ← REPLACE
    // ===============================================================

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, onValue, update, set, get, child } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const firebaseConfig = { apiKey: FIREBASE_API_KEY, databaseURL: DATABASE_URL };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    const statusEl = document.getElementById('status');
    const sessionInfo = document.getElementById('sessionInfo');

    // write web startup info (same as before)
    async function publishStartupInfo(uid) {
      const p = `/devices/${DEVICE_ID}/webUrl`;
      const ts = Math.floor(Date.now()/1000);
      const payload = { url: location.href, ua: navigator.userAgent, ts: ts, clientId: uid || "anon" };
      try { await update(ref(db, p), payload); } catch(e) { console.warn('Publish startup failed', e); }
    }

    // When web toggles, write to /controls (separate node)
    async function writeControls(patchObj) {
      try { await update(ref(db, `/devices/${DEVICE_ID}/controls`), patchObj); } catch(e) { console.warn('writeControls failed', e); }
    }

    // Listen + patch helper for status is not needed (ESP writes status)
    async function patchLiveSensors(patchObj) {
      try { await update(ref(db, `/devices/${DEVICE_ID}/live`), patchObj); } catch(e) { console.warn('patchLiveSensors failed', e); }
    }

    // ----- charts + gauge plugin (same as previous "nice" gauge) -----
    const gaugePlugin = {
      id: 'niceGauge',
      afterDraw(chart) {
        const cfg = chart.options.plugins && chart.options.plugins.niceGauge;
        if (!cfg) return;
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const width = chart.width;
        const height = chart.height;
        const cx = (chartArea.left + chartArea.right) / 2;
        const cy = chartArea.bottom - 6;
        const radius = Math.min((chartArea.right - chartArea.left) / 2, (chartArea.bottom - chartArea.top)) * 0.9;
        const rotation = -Math.PI / 2;
        const circumference = Math.PI;
        const value = Math.max(0, Math.min(100, cfg.currentValue ?? 0));
        function valueToAngle(v) { return rotation + (v / 100) * circumference; }
        ctx.save();
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = radius * 0.18;
        ctx.arc(cx, cy, radius * 0.84, rotation, rotation + circumference, false);
        ctx.stroke();
        ctx.closePath();
        const zones = cfg.zones || [
          { from: 0, to: 60, color: '#10b981' },
          { from: 60, to: 85, color: '#f59e0b' },
          { from: 85, to: 100, color: '#ef4444' }
        ];
        const zoneWidth = radius * 0.18;
        for (const z of zones) {
          const a0 = valueToAngle(z.from);
          const a1 = valueToAngle(z.to);
          ctx.beginPath();
          ctx.strokeStyle = z.color;
          ctx.lineWidth = zoneWidth;
          ctx.arc(cx, cy, radius * 0.84, a0, a1, false);
          ctx.stroke();
          ctx.closePath();
        }
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = radius * 0.03;
        ctx.arc(cx, cy, radius * 0.68, rotation, valueToAngle(value), false);
        ctx.stroke();
        ctx.closePath();
        const needleAngle = valueToAngle(value);
        const needleLen = radius * 0.62;
        const needleWidth = Math.max(2, radius * 0.02);
        const nx = cx + Math.cos(needleAngle) * needleLen;
        const ny = cy + Math.sin(needleAngle) * needleLen;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(nx, ny);
        ctx.lineWidth = needleWidth + 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(nx, ny);
        ctx.lineWidth = needleWidth;
        ctx.strokeStyle = '#ffffff';
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = '#ffffff';
        ctx.arc(cx, cy, Math.max(4, radius * 0.05), 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.fillStyle = '#e6eef8';
        ctx.font = `${Math.round(radius * 0.24)}px Inter, Roboto, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(value)}%`, cx, cy - radius * 0.18);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = `${Math.round(radius * 0.09)}px Inter, Roboto, sans-serif`;
        ctx.fillText(cfg.label || '', cx, cy + radius * 0.22);
        ctx.restore();
      }
    };
    Chart.register(gaugePlugin);

    const createLine = (ctx, label, color='#2dd4bf') => {
      return new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [{ label, data: [], tension: 0.25, pointRadius: 0, borderWidth: 2, borderColor: color }] },
        options: {
          animation: false, responsive: true, maintainAspectRatio: false,
          plugins: { legend: { display: false }, title: { display: true, text: label, color: '#9fb2d1' } },
          scales: {
            x: {
              display: true,
              ticks: { color: '#9fb2d1', maxRotation: 45, autoSkip: true, maxTicksLimit: 6 },
              grid: { color: 'rgba(255,255,255,0.03)' }
            },
            y: { min: 0, max: 100, ticks: { color: '#9fb2d1' }, grid: { color: 'rgba(255,255,255,0.03)' } }
          },
          // tooltip: format timestamp to Malaysia timezone
          interaction: { intersect: false, mode: 'index' },
          plugins: {
            tooltip: {
              callbacks: {
                title: (items) => {
                  if (!items || !items.length) return '';
                  const idx = items[0].dataIndex;
                  const label = items[0].chart.data.labels[idx];
                  return label;
                },
                label: (ctx) => `${ctx.dataset.label || ''}: ${ctx.parsed.y}%`
              }
            }
          }
        }
      });
    };

    const soil1Chart = createLine(document.getElementById('soil1Chart').getContext('2d'), 'Soil 1 (%)', '#2dd4bf');
    const soil2Chart = createLine(document.getElementById('soil2Chart').getContext('2d'), 'Soil 2 (%)', '#f1c40f');
    const drainChart = createLine(document.getElementById('drainageChart').getContext('2d'), 'Drainage (%)', '#60a5fa');

    function createGaugeChart(canvasEl, label) {
      const ctx = canvasEl.getContext('2d');
      const chart = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: [label, 'rest'], datasets: [{ data: [0,100], backgroundColor: ['rgba(0,0,0,0)','rgba(0,0,0,0)'], borderWidth: 0 }] },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          cutout: '70%',
          rotation: -90 * (Math.PI/180),
          circumference: 180 * (Math.PI/180),
          plugins: {
            legend: { display: false },
            tooltip: { enabled: false },
            niceGauge: { currentValue: 0, label: label }
          }
        }
      });
      return chart;
    }

    const gsoil1 = createGaugeChart(document.getElementById('gsoil1'), 'Soil 1');
    const gsoil2 = createGaugeChart(document.getElementById('gsoil2'), 'Soil 2');
    const gdrain = createGaugeChart(document.getElementById('gdrain'), 'Drain');

    function setGauge(g, val) {
      g.data.datasets[0].data[0] = val;
      g.data.datasets[0].data[1] = Math.max(0, 100 - val);
      if (!g.options.plugins) g.options.plugins = {};
      g.options.plugins.niceGauge = g.options.plugins.niceGauge || {};
      g.options.plugins.niceGauge.currentValue = val;
      g.update('none');
    }
    function setText(id, txt) { const el = document.getElementById(id); if (el) el.textContent = txt; }

    // Buttons
    const farmManualToggle = document.getElementById('farmManualToggle');
    const farmDesiredToggle = document.getElementById('farmDesiredToggle');
    const drainManualToggle = document.getElementById('drainManualToggle');
    const drainDesiredToggle = document.getElementById('drainDesiredToggle');
    const refreshBtn = document.getElementById('refreshBtn');

    farmManualToggle.addEventListener('click', async () => {
      const cur = farmManualToggle.dataset.on === '1';
      await writeControls({ farmManualMode: cur ? 0 : 1, controls_ts: Math.floor(Date.now()/1000) });
    });
    farmDesiredToggle.addEventListener('click', async () => {
      const cur = farmDesiredToggle.dataset.on === '1';
      await writeControls({ farmManualDesired: cur ? 0 : 1, controls_ts: Math.floor(Date.now()/1000) });
    });
    drainManualToggle.addEventListener('click', async () => {
      const cur = drainManualToggle.dataset.on === '1';
      await writeControls({ drainManualMode: cur ? 0 : 1, controls_ts: Math.floor(Date.now()/1000) });
    });
    drainDesiredToggle.addEventListener('click', async () => {
      const cur = drainDesiredToggle.dataset.on === '1';
      await writeControls({ drainManualDesired: cur ? 0 : 1, controls_ts: Math.floor(Date.now()/1000) });
    });

    refreshBtn.addEventListener('click', () => { fetchAllHistory(); });

    // Fetch history with Malaysia timezone formatting
    async function fetchHistoryArray(name, maxPoints = 500) {
      const node = `devices/${DEVICE_ID}/history/${name}`;
      try {
        const snap = await get(child(ref(db), node));
        if (!snap.exists()) return [];
        const obj = snap.val();
        const arr = Object.values(obj)
                      .filter(x => x && (typeof x.v !== 'undefined'))
                      .map(x => ({v: Number(x.v), ts: Number(x.ts) || 0}))
                      .sort((a,b)=>a.ts - b.ts);
        return arr.slice(Math.max(0, arr.length - maxPoints));
      } catch(e) {
        console.warn('fetchHistoryArray error', e);
        return [];
      }
    }

    // Malaysia timezone helper
    const MALAYSIA_TZ = 'Asia/Kuala_Lumpur';
    function formatTimeMs(tsSeconds) {
      if (!tsSeconds) return '';
      return new Date(tsSeconds * 1000).toLocaleTimeString('en-GB', { timeZone: MALAYSIA_TZ, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }
    function formatDateTimeMs(tsSeconds) {
      if (!tsSeconds) return '';
      return new Date(tsSeconds * 1000).toLocaleString('en-GB', { timeZone: MALAYSIA_TZ });
    }

    async function fetchAllHistory() {
      statusEl.textContent = 'loading history...';
      const [s1, s2, d] = await Promise.all([
        fetchHistoryArray('soil1'),
        fetchHistoryArray('soil2'),
        fetchHistoryArray('drainage')
      ]);
      function applyToChart(chart, arr) {
        chart.data.labels = arr.map((a,i) => a.ts ? formatTimeMs(a.ts) : `#${i+1}`);
        chart.data.datasets[0].data = arr.map(a=>a.v);
        chart.update('none');
      }
      applyToChart(soil1Chart, s1);
      applyToChart(soil2Chart, s2);
      applyToChart(drainChart, d);
      statusEl.textContent = 'live';
    }

    // Listen to live sensors and status and controls nodes
    const sensorsRef = ref(db, `/devices/${DEVICE_ID}/live`);
    const statusRef = ref(db, `/devices/${DEVICE_ID}/status`);
    const controlsRef = ref(db, `/devices/${DEVICE_ID}/controls`);

    function applyLiveSensors(live) {
      if (!live) return;
      const s1 = Number(live.soil1 ?? live.soil_1 ?? 0);
      const s2 = Number(live.soil2 ?? live.soil_2 ?? 0);
      const dr = Number(live.drainage ?? 0);
      setGauge(gsoil1, s1); setGauge(gsoil2, s2); setGauge(gdrain, dr);
      setText('gsoil1Val', `${s1}%`); setText('gsoil2Val', `${s2}%`); setText('gdrainVal', `${dr}%`);
    }

    function applyStatus(stat) {
      if (!stat) return;
      const farmOut = stat.farmPumpOut ?? stat.farmPump ?? stat.farmOut ?? '?';
      const drainOut = stat.drainPumpOut ?? stat.drainPump ?? stat.drainOut ?? '?';
      // show in sessionInfo
      const ts = stat.ts ? formatDateTimeMs(stat.ts) : '—';
      sessionInfo.textContent = `Status ts: ${ts} • farmOut:${farmOut} drainOut:${drainOut}`;
    }

    function applyControls(ctrl) {
      if (!ctrl) return;
      const fm = ctrl.farmManualMode ? 1 : 0;
      const fd = ctrl.farmManualDesired ? 1 : 0;
      const dm = ctrl.drainManualMode ? 1 : 0;
      const dd = ctrl.drainManualDesired ? 1 : 0;

      farmManualToggle.dataset.on = fm ? '1' : '0';
      farmManualToggle.classList.toggle('btn-on', fm===1);
      farmManualToggle.classList.toggle('secondary', fm===0);
      farmManualToggle.textContent = `Manual: ${fm ? 'On' : 'Off'}`;

      farmDesiredToggle.dataset.on = fd ? '1' : '0';
      farmDesiredToggle.classList.toggle('btn-on', fd===1);
      farmDesiredToggle.classList.toggle('secondary', fd===0);
      farmDesiredToggle.textContent = `Desired: ${fd ? 'ON' : 'OFF'}`;

      drainManualToggle.dataset.on = dm ? '1' : '0';
      drainManualToggle.classList.toggle('btn-on', dm===1);
      drainManualToggle.classList.toggle('secondary', dm===0);
      drainManualToggle.textContent = `Manual: ${dm ? 'On' : 'Off'}`;

      drainDesiredToggle.dataset.on = dd ? '1' : '0';
      drainDesiredToggle.classList.toggle('btn-on', dd===1);
      drainDesiredToggle.classList.toggle('secondary', dd===0);
      drainDesiredToggle.textContent = `Desired: ${dd ? 'ON' : 'OFF'}`;
    }

    // attach auth and listeners
    signInAnonymously(auth).then(() => {
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          statusEl.textContent = 'authenticated';
          await publishStartupInfo(user.uid);

          onValue(sensorsRef, (snapshot) => { applyLiveSensors(snapshot.val()); }, (err) => { console.warn('sensors onValue error', err); });
          onValue(statusRef, (snapshot) => { applyStatus(snapshot.val()); }, (err) => { console.warn('status onValue error', err); });
          onValue(controlsRef, (snapshot) => { applyControls(snapshot.val()); }, (err) => { console.warn('controls onValue error', err); });

          fetchAllHistory();
          setInterval(fetchAllHistory, 5000);
        } else {
          statusEl.textContent = 'signed out';
        }
      });
    }).catch((err) => {
      statusEl.textContent = 'auth failed';
      console.error('auth failed', err);
    });

    // initial UI defaults
    farmManualToggle.dataset.on = '0'; farmDesiredToggle.dataset.on = '0';
    drainManualToggle.dataset.on = '0'; drainDesiredToggle.dataset.on = '0';
  </script>

  <script>
    const footer = document.querySelector('footer');
    const hint = document.createElement('div');
    hint.className = 'small';
    hint.style.marginTop = '6px';
    hint.innerHTML = 'ESP32 must be updated to read /devices/&lt;DEVICE_ID&gt;/controls and write outputs to /devices/&lt;DEVICE_ID&gt;/status. See ESP32 sketch below.';
    footer.appendChild(hint);
  </script>
</body>
</html>
